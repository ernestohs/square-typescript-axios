"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Square Connect API
 * Client library for accessing the Square Connect APIs
 *
 * The version of the OpenAPI document: 2.0
 * Contact: developers@squareup.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DisputesApi = exports.DisputesApiFactory = exports.DisputesApiFp = exports.DisputesApiAxiosParamCreator = void 0;
var axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
var base_1 = require("../base");
/**
 * DisputesApi - axios parameter creator
 * @export
 */
exports.DisputesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Accepts loss on a dispute. Square returns the disputed amount to the cardholder and updates the dispute state to ACCEPTED.  Square debits the disputed amount from the seller’s Square account. If the Square account balance does not have sufficient funds, Square debits the associated bank account.
         * @summary AcceptDispute
         * @param {string} disputeId ID of the dispute you want to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDispute: function (disputeId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarAccessTokenValue, _a, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'disputeId' is not null or undefined
                            if (disputeId === null || disputeId === undefined) {
                                throw new base_1.RequiredError('disputeId', 'Required parameter disputeId was null or undefined when calling acceptDispute.');
                            }
                            localVarPath = "/v2/disputes/{dispute_id}/accept"
                                .replace("{" + "dispute_id" + "}", encodeURIComponent(String(disputeId)));
                            localVarUrlObj = new URL(localVarPath, 'https://connect.squareupsandbox.com');
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.accessToken)) return [3 /*break*/, 5];
                            if (!(typeof configuration.accessToken === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.accessToken("oauth2", ["PAYMENTS_WRITE"])];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.accessToken];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarAccessTokenValue = _a;
                            localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
                            _b.label = 5;
                        case 5:
                            queryParameters = new URLSearchParams(localVarUrlObj.search);
                            for (key in localVarQueryParameter) {
                                queryParameters.set(key, localVarQueryParameter[key]);
                            }
                            for (key in options.query) {
                                queryParameters.set(key, options.query[key]);
                            }
                            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Uploads text to use as evidence for a dispute challenge.
         * @summary CreateDisputeEvidenceText
         * @param {string} disputeId The ID of the dispute you want to upload evidence for.
         * @param {CreateDisputeEvidenceTextRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDisputeEvidenceText: function (disputeId, body, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarAccessTokenValue, _a, queryParameters, key, key, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'disputeId' is not null or undefined
                            if (disputeId === null || disputeId === undefined) {
                                throw new base_1.RequiredError('disputeId', 'Required parameter disputeId was null or undefined when calling createDisputeEvidenceText.');
                            }
                            // verify required parameter 'body' is not null or undefined
                            if (body === null || body === undefined) {
                                throw new base_1.RequiredError('body', 'Required parameter body was null or undefined when calling createDisputeEvidenceText.');
                            }
                            localVarPath = "/v2/disputes/{dispute_id}/evidence_text"
                                .replace("{" + "dispute_id" + "}", encodeURIComponent(String(disputeId)));
                            localVarUrlObj = new URL(localVarPath, 'https://connect.squareupsandbox.com');
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.accessToken)) return [3 /*break*/, 5];
                            if (!(typeof configuration.accessToken === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.accessToken("oauth2", ["PAYMENTS_WRITE"])];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.accessToken];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarAccessTokenValue = _a;
                            localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
                            _b.label = 5;
                        case 5:
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            queryParameters = new URLSearchParams(localVarUrlObj.search);
                            for (key in localVarQueryParameter) {
                                queryParameters.set(key, localVarQueryParameter[key]);
                            }
                            for (key in options.query) {
                                queryParameters.set(key, options.query[key]);
                            }
                            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
                            localVarRequestOptions.data = needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");
                            return [2 /*return*/, {
                                    url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Returns a list of evidence associated with a dispute.
         * @summary ListDisputeEvidence
         * @param {string} disputeId The ID of the dispute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputeEvidence: function (disputeId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarAccessTokenValue, _a, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'disputeId' is not null or undefined
                            if (disputeId === null || disputeId === undefined) {
                                throw new base_1.RequiredError('disputeId', 'Required parameter disputeId was null or undefined when calling listDisputeEvidence.');
                            }
                            localVarPath = "/v2/disputes/{dispute_id}/evidence"
                                .replace("{" + "dispute_id" + "}", encodeURIComponent(String(disputeId)));
                            localVarUrlObj = new URL(localVarPath, 'https://connect.squareupsandbox.com');
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.accessToken)) return [3 /*break*/, 5];
                            if (!(typeof configuration.accessToken === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.accessToken("oauth2", ["PAYMENTS_READ"])];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.accessToken];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarAccessTokenValue = _a;
                            localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
                            _b.label = 5;
                        case 5:
                            queryParameters = new URLSearchParams(localVarUrlObj.search);
                            for (key in localVarQueryParameter) {
                                queryParameters.set(key, localVarQueryParameter[key]);
                            }
                            for (key in options.query) {
                                queryParameters.set(key, options.query[key]);
                            }
                            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Returns a list of disputes associated with a particular account.
         * @summary ListDisputes
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query. For more information, see [Paginating](https://developer.squareup.com/docs/basics/api101/pagination).
         * @param {string} [states] The dispute states to filter the result. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or &#x60;LOST&#x60;).
         * @param {string} [locationId] The ID of the location for which to return  a list of disputes. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or  &#x60;LOST&#x60;) associated with all locations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputes: function (cursor, states, locationId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarAccessTokenValue, _a, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            localVarPath = "/v2/disputes";
                            localVarUrlObj = new URL(localVarPath, 'https://connect.squareupsandbox.com');
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.accessToken)) return [3 /*break*/, 5];
                            if (!(typeof configuration.accessToken === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.accessToken("oauth2", ["PAYMENTS_READ"])];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.accessToken];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarAccessTokenValue = _a;
                            localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
                            _b.label = 5;
                        case 5:
                            if (cursor !== undefined) {
                                localVarQueryParameter['cursor'] = cursor;
                            }
                            if (states !== undefined) {
                                localVarQueryParameter['states'] = states;
                            }
                            if (locationId !== undefined) {
                                localVarQueryParameter['location_id'] = locationId;
                            }
                            queryParameters = new URLSearchParams(localVarUrlObj.search);
                            for (key in localVarQueryParameter) {
                                queryParameters.set(key, localVarQueryParameter[key]);
                            }
                            for (key in options.query) {
                                queryParameters.set(key, options.query[key]);
                            }
                            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Removes specified evidence from a dispute.  Square does not send the bank any evidence that is removed. Also, you cannot remove evidence after submitting it to the bank using [SubmitEvidence](/reference/square/disputes-api/submit-evidence).
         * @summary RemoveDisputeEvidence
         * @param {string} disputeId The ID of the dispute you want to remove evidence from.
         * @param {string} evidenceId The ID of the evidence you want to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDisputeEvidence: function (disputeId, evidenceId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarAccessTokenValue, _a, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'disputeId' is not null or undefined
                            if (disputeId === null || disputeId === undefined) {
                                throw new base_1.RequiredError('disputeId', 'Required parameter disputeId was null or undefined when calling removeDisputeEvidence.');
                            }
                            // verify required parameter 'evidenceId' is not null or undefined
                            if (evidenceId === null || evidenceId === undefined) {
                                throw new base_1.RequiredError('evidenceId', 'Required parameter evidenceId was null or undefined when calling removeDisputeEvidence.');
                            }
                            localVarPath = "/v2/disputes/{dispute_id}/evidence/{evidence_id}"
                                .replace("{" + "dispute_id" + "}", encodeURIComponent(String(disputeId)))
                                .replace("{" + "evidence_id" + "}", encodeURIComponent(String(evidenceId)));
                            localVarUrlObj = new URL(localVarPath, 'https://connect.squareupsandbox.com');
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.accessToken)) return [3 /*break*/, 5];
                            if (!(typeof configuration.accessToken === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.accessToken("oauth2", ["PAYMENTS_WRITE"])];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.accessToken];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarAccessTokenValue = _a;
                            localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
                            _b.label = 5;
                        case 5:
                            queryParameters = new URLSearchParams(localVarUrlObj.search);
                            for (key in localVarQueryParameter) {
                                queryParameters.set(key, localVarQueryParameter[key]);
                            }
                            for (key in options.query) {
                                queryParameters.set(key, options.query[key]);
                            }
                            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Returns details of a specific dispute.
         * @summary RetrieveDispute
         * @param {string} disputeId The ID of the dispute you want more details about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDispute: function (disputeId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarAccessTokenValue, _a, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'disputeId' is not null or undefined
                            if (disputeId === null || disputeId === undefined) {
                                throw new base_1.RequiredError('disputeId', 'Required parameter disputeId was null or undefined when calling retrieveDispute.');
                            }
                            localVarPath = "/v2/disputes/{dispute_id}"
                                .replace("{" + "dispute_id" + "}", encodeURIComponent(String(disputeId)));
                            localVarUrlObj = new URL(localVarPath, 'https://connect.squareupsandbox.com');
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.accessToken)) return [3 /*break*/, 5];
                            if (!(typeof configuration.accessToken === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.accessToken("oauth2", ["PAYMENTS_READ"])];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.accessToken];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarAccessTokenValue = _a;
                            localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
                            _b.label = 5;
                        case 5:
                            queryParameters = new URLSearchParams(localVarUrlObj.search);
                            for (key in localVarQueryParameter) {
                                queryParameters.set(key, localVarQueryParameter[key]);
                            }
                            for (key in options.query) {
                                queryParameters.set(key, options.query[key]);
                            }
                            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Returns the specific evidence metadata associated with a specific dispute.  You must maintain a copy of the evidence you upload if you want to reference it later. You cannot download the evidence after you upload it.
         * @summary RetrieveDisputeEvidence
         * @param {string} disputeId The ID of the dispute that you want to retrieve evidence from.
         * @param {string} evidenceId The ID of the evidence to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDisputeEvidence: function (disputeId, evidenceId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarAccessTokenValue, _a, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'disputeId' is not null or undefined
                            if (disputeId === null || disputeId === undefined) {
                                throw new base_1.RequiredError('disputeId', 'Required parameter disputeId was null or undefined when calling retrieveDisputeEvidence.');
                            }
                            // verify required parameter 'evidenceId' is not null or undefined
                            if (evidenceId === null || evidenceId === undefined) {
                                throw new base_1.RequiredError('evidenceId', 'Required parameter evidenceId was null or undefined when calling retrieveDisputeEvidence.');
                            }
                            localVarPath = "/v2/disputes/{dispute_id}/evidence/{evidence_id}"
                                .replace("{" + "dispute_id" + "}", encodeURIComponent(String(disputeId)))
                                .replace("{" + "evidence_id" + "}", encodeURIComponent(String(evidenceId)));
                            localVarUrlObj = new URL(localVarPath, 'https://connect.squareupsandbox.com');
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.accessToken)) return [3 /*break*/, 5];
                            if (!(typeof configuration.accessToken === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.accessToken("oauth2", ["PAYMENTS_READ"])];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.accessToken];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarAccessTokenValue = _a;
                            localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
                            _b.label = 5;
                        case 5:
                            queryParameters = new URLSearchParams(localVarUrlObj.search);
                            for (key in localVarQueryParameter) {
                                queryParameters.set(key, localVarQueryParameter[key]);
                            }
                            for (key in options.query) {
                                queryParameters.set(key, options.query[key]);
                            }
                            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Submits evidence to the cardholder\'s bank.  Before submitting evidence, Square compiles all available evidence. This includes evidence uploaded using the [CreateDisputeEvidenceFile](/reference/square/disputes-api/create-dispute-evidence-file) and [CreateDisputeEvidenceText](/reference/square/disputes-api/create-dispute-evidence-text) endpoints, and evidence automatically provided by Square, when available.
         * @summary SubmitEvidence
         * @param {string} disputeId The ID of the dispute you want to submit evidence for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitEvidence: function (disputeId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarAccessTokenValue, _a, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'disputeId' is not null or undefined
                            if (disputeId === null || disputeId === undefined) {
                                throw new base_1.RequiredError('disputeId', 'Required parameter disputeId was null or undefined when calling submitEvidence.');
                            }
                            localVarPath = "/v2/disputes/{dispute_id}/submit-evidence"
                                .replace("{" + "dispute_id" + "}", encodeURIComponent(String(disputeId)));
                            localVarUrlObj = new URL(localVarPath, 'https://connect.squareupsandbox.com');
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.accessToken)) return [3 /*break*/, 5];
                            if (!(typeof configuration.accessToken === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.accessToken("oauth2", ["PAYMENTS_WRITE"])];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.accessToken];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarAccessTokenValue = _a;
                            localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
                            _b.label = 5;
                        case 5:
                            queryParameters = new URLSearchParams(localVarUrlObj.search);
                            for (key in localVarQueryParameter) {
                                queryParameters.set(key, localVarQueryParameter[key]);
                            }
                            for (key in options.query) {
                                queryParameters.set(key, options.query[key]);
                            }
                            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
/**
 * DisputesApi - functional programming interface
 * @export
 */
exports.DisputesApiFp = function (configuration) {
    return {
        /**
         * Accepts loss on a dispute. Square returns the disputed amount to the cardholder and updates the dispute state to ACCEPTED.  Square debits the disputed amount from the seller’s Square account. If the Square account balance does not have sufficient funds, Square debits the associated bank account.
         * @summary AcceptDispute
         * @param {string} disputeId ID of the dispute you want to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDispute: function (disputeId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.DisputesApiAxiosParamCreator(configuration).acceptDispute(disputeId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Uploads text to use as evidence for a dispute challenge.
         * @summary CreateDisputeEvidenceText
         * @param {string} disputeId The ID of the dispute you want to upload evidence for.
         * @param {CreateDisputeEvidenceTextRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDisputeEvidenceText: function (disputeId, body, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.DisputesApiAxiosParamCreator(configuration).createDisputeEvidenceText(disputeId, body, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Returns a list of evidence associated with a dispute.
         * @summary ListDisputeEvidence
         * @param {string} disputeId The ID of the dispute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputeEvidence: function (disputeId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.DisputesApiAxiosParamCreator(configuration).listDisputeEvidence(disputeId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Returns a list of disputes associated with a particular account.
         * @summary ListDisputes
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query. For more information, see [Paginating](https://developer.squareup.com/docs/basics/api101/pagination).
         * @param {string} [states] The dispute states to filter the result. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or &#x60;LOST&#x60;).
         * @param {string} [locationId] The ID of the location for which to return  a list of disputes. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or  &#x60;LOST&#x60;) associated with all locations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputes: function (cursor, states, locationId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.DisputesApiAxiosParamCreator(configuration).listDisputes(cursor, states, locationId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Removes specified evidence from a dispute.  Square does not send the bank any evidence that is removed. Also, you cannot remove evidence after submitting it to the bank using [SubmitEvidence](/reference/square/disputes-api/submit-evidence).
         * @summary RemoveDisputeEvidence
         * @param {string} disputeId The ID of the dispute you want to remove evidence from.
         * @param {string} evidenceId The ID of the evidence you want to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDisputeEvidence: function (disputeId, evidenceId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.DisputesApiAxiosParamCreator(configuration).removeDisputeEvidence(disputeId, evidenceId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Returns details of a specific dispute.
         * @summary RetrieveDispute
         * @param {string} disputeId The ID of the dispute you want more details about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDispute: function (disputeId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.DisputesApiAxiosParamCreator(configuration).retrieveDispute(disputeId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Returns the specific evidence metadata associated with a specific dispute.  You must maintain a copy of the evidence you upload if you want to reference it later. You cannot download the evidence after you upload it.
         * @summary RetrieveDisputeEvidence
         * @param {string} disputeId The ID of the dispute that you want to retrieve evidence from.
         * @param {string} evidenceId The ID of the evidence to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDisputeEvidence: function (disputeId, evidenceId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.DisputesApiAxiosParamCreator(configuration).retrieveDisputeEvidence(disputeId, evidenceId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Submits evidence to the cardholder\'s bank.  Before submitting evidence, Square compiles all available evidence. This includes evidence uploaded using the [CreateDisputeEvidenceFile](/reference/square/disputes-api/create-dispute-evidence-file) and [CreateDisputeEvidenceText](/reference/square/disputes-api/create-dispute-evidence-text) endpoints, and evidence automatically provided by Square, when available.
         * @summary SubmitEvidence
         * @param {string} disputeId The ID of the dispute you want to submit evidence for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitEvidence: function (disputeId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.DisputesApiAxiosParamCreator(configuration).submitEvidence(disputeId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
/**
 * DisputesApi - factory interface
 * @export
 */
exports.DisputesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Accepts loss on a dispute. Square returns the disputed amount to the cardholder and updates the dispute state to ACCEPTED.  Square debits the disputed amount from the seller’s Square account. If the Square account balance does not have sufficient funds, Square debits the associated bank account.
         * @summary AcceptDispute
         * @param {string} disputeId ID of the dispute you want to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDispute: function (disputeId, options) {
            return exports.DisputesApiFp(configuration).acceptDispute(disputeId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Uploads text to use as evidence for a dispute challenge.
         * @summary CreateDisputeEvidenceText
         * @param {string} disputeId The ID of the dispute you want to upload evidence for.
         * @param {CreateDisputeEvidenceTextRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDisputeEvidenceText: function (disputeId, body, options) {
            return exports.DisputesApiFp(configuration).createDisputeEvidenceText(disputeId, body, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a list of evidence associated with a dispute.
         * @summary ListDisputeEvidence
         * @param {string} disputeId The ID of the dispute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputeEvidence: function (disputeId, options) {
            return exports.DisputesApiFp(configuration).listDisputeEvidence(disputeId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a list of disputes associated with a particular account.
         * @summary ListDisputes
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query. For more information, see [Paginating](https://developer.squareup.com/docs/basics/api101/pagination).
         * @param {string} [states] The dispute states to filter the result. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or &#x60;LOST&#x60;).
         * @param {string} [locationId] The ID of the location for which to return  a list of disputes. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or  &#x60;LOST&#x60;) associated with all locations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputes: function (cursor, states, locationId, options) {
            return exports.DisputesApiFp(configuration).listDisputes(cursor, states, locationId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Removes specified evidence from a dispute.  Square does not send the bank any evidence that is removed. Also, you cannot remove evidence after submitting it to the bank using [SubmitEvidence](/reference/square/disputes-api/submit-evidence).
         * @summary RemoveDisputeEvidence
         * @param {string} disputeId The ID of the dispute you want to remove evidence from.
         * @param {string} evidenceId The ID of the evidence you want to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDisputeEvidence: function (disputeId, evidenceId, options) {
            return exports.DisputesApiFp(configuration).removeDisputeEvidence(disputeId, evidenceId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns details of a specific dispute.
         * @summary RetrieveDispute
         * @param {string} disputeId The ID of the dispute you want more details about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDispute: function (disputeId, options) {
            return exports.DisputesApiFp(configuration).retrieveDispute(disputeId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns the specific evidence metadata associated with a specific dispute.  You must maintain a copy of the evidence you upload if you want to reference it later. You cannot download the evidence after you upload it.
         * @summary RetrieveDisputeEvidence
         * @param {string} disputeId The ID of the dispute that you want to retrieve evidence from.
         * @param {string} evidenceId The ID of the evidence to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDisputeEvidence: function (disputeId, evidenceId, options) {
            return exports.DisputesApiFp(configuration).retrieveDisputeEvidence(disputeId, evidenceId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Submits evidence to the cardholder\'s bank.  Before submitting evidence, Square compiles all available evidence. This includes evidence uploaded using the [CreateDisputeEvidenceFile](/reference/square/disputes-api/create-dispute-evidence-file) and [CreateDisputeEvidenceText](/reference/square/disputes-api/create-dispute-evidence-text) endpoints, and evidence automatically provided by Square, when available.
         * @summary SubmitEvidence
         * @param {string} disputeId The ID of the dispute you want to submit evidence for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitEvidence: function (disputeId, options) {
            return exports.DisputesApiFp(configuration).submitEvidence(disputeId, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
/**
 * DisputesApi - object-oriented interface
 * @export
 * @class DisputesApi
 * @extends {BaseAPI}
 */
var DisputesApi = /** @class */ (function (_super) {
    __extends(DisputesApi, _super);
    function DisputesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Accepts loss on a dispute. Square returns the disputed amount to the cardholder and updates the dispute state to ACCEPTED.  Square debits the disputed amount from the seller’s Square account. If the Square account balance does not have sufficient funds, Square debits the associated bank account.
     * @summary AcceptDispute
     * @param {string} disputeId ID of the dispute you want to accept.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    DisputesApi.prototype.acceptDispute = function (disputeId, options) {
        var _this = this;
        return exports.DisputesApiFp(this.configuration).acceptDispute(disputeId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Uploads text to use as evidence for a dispute challenge.
     * @summary CreateDisputeEvidenceText
     * @param {string} disputeId The ID of the dispute you want to upload evidence for.
     * @param {CreateDisputeEvidenceTextRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    DisputesApi.prototype.createDisputeEvidenceText = function (disputeId, body, options) {
        var _this = this;
        return exports.DisputesApiFp(this.configuration).createDisputeEvidenceText(disputeId, body, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a list of evidence associated with a dispute.
     * @summary ListDisputeEvidence
     * @param {string} disputeId The ID of the dispute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    DisputesApi.prototype.listDisputeEvidence = function (disputeId, options) {
        var _this = this;
        return exports.DisputesApiFp(this.configuration).listDisputeEvidence(disputeId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a list of disputes associated with a particular account.
     * @summary ListDisputes
     * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query. For more information, see [Paginating](https://developer.squareup.com/docs/basics/api101/pagination).
     * @param {string} [states] The dispute states to filter the result. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or &#x60;LOST&#x60;).
     * @param {string} [locationId] The ID of the location for which to return  a list of disputes. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or  &#x60;LOST&#x60;) associated with all locations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    DisputesApi.prototype.listDisputes = function (cursor, states, locationId, options) {
        var _this = this;
        return exports.DisputesApiFp(this.configuration).listDisputes(cursor, states, locationId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Removes specified evidence from a dispute.  Square does not send the bank any evidence that is removed. Also, you cannot remove evidence after submitting it to the bank using [SubmitEvidence](/reference/square/disputes-api/submit-evidence).
     * @summary RemoveDisputeEvidence
     * @param {string} disputeId The ID of the dispute you want to remove evidence from.
     * @param {string} evidenceId The ID of the evidence you want to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    DisputesApi.prototype.removeDisputeEvidence = function (disputeId, evidenceId, options) {
        var _this = this;
        return exports.DisputesApiFp(this.configuration).removeDisputeEvidence(disputeId, evidenceId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns details of a specific dispute.
     * @summary RetrieveDispute
     * @param {string} disputeId The ID of the dispute you want more details about.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    DisputesApi.prototype.retrieveDispute = function (disputeId, options) {
        var _this = this;
        return exports.DisputesApiFp(this.configuration).retrieveDispute(disputeId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns the specific evidence metadata associated with a specific dispute.  You must maintain a copy of the evidence you upload if you want to reference it later. You cannot download the evidence after you upload it.
     * @summary RetrieveDisputeEvidence
     * @param {string} disputeId The ID of the dispute that you want to retrieve evidence from.
     * @param {string} evidenceId The ID of the evidence to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    DisputesApi.prototype.retrieveDisputeEvidence = function (disputeId, evidenceId, options) {
        var _this = this;
        return exports.DisputesApiFp(this.configuration).retrieveDisputeEvidence(disputeId, evidenceId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Submits evidence to the cardholder\'s bank.  Before submitting evidence, Square compiles all available evidence. This includes evidence uploaded using the [CreateDisputeEvidenceFile](/reference/square/disputes-api/create-dispute-evidence-file) and [CreateDisputeEvidenceText](/reference/square/disputes-api/create-dispute-evidence-text) endpoints, and evidence automatically provided by Square, when available.
     * @summary SubmitEvidence
     * @param {string} disputeId The ID of the dispute you want to submit evidence for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    DisputesApi.prototype.submitEvidence = function (disputeId, options) {
        var _this = this;
        return exports.DisputesApiFp(this.configuration).submitEvidence(disputeId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return DisputesApi;
}(base_1.BaseAPI));
exports.DisputesApi = DisputesApi;
