/* tslint:disable */
/* eslint-disable */
/**
 * Square Connect API
 * Client library for accessing the Square Connect APIs
 *
 * The version of the OpenAPI document: 2.0
 * Contact: developers@squareup.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AcceptDisputeResponse } from '../models';
// @ts-ignore
import { CreateDisputeEvidenceTextRequest } from '../models';
// @ts-ignore
import { CreateDisputeEvidenceTextResponse } from '../models';
// @ts-ignore
import { ListDisputeEvidenceResponse } from '../models';
// @ts-ignore
import { ListDisputesResponse } from '../models';
// @ts-ignore
import { RemoveDisputeEvidenceResponse } from '../models';
// @ts-ignore
import { RetrieveDisputeEvidenceResponse } from '../models';
// @ts-ignore
import { RetrieveDisputeResponse } from '../models';
// @ts-ignore
import { SubmitEvidenceResponse } from '../models';
/**
 * DisputesApi - axios parameter creator
 * @export
 */
export const DisputesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accepts loss on a dispute. Square returns the disputed amount to the cardholder and updates the dispute state to ACCEPTED.  Square debits the disputed amount from the seller’s Square account. If the Square account balance does not have sufficient funds, Square debits the associated bank account.
         * @summary AcceptDispute
         * @param {string} disputeId ID of the dispute you want to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDispute: async (disputeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'disputeId' is not null or undefined
            if (disputeId === null || disputeId === undefined) {
                throw new RequiredError('disputeId','Required parameter disputeId was null or undefined when calling acceptDispute.');
            }
            const localVarPath = `/v2/disputes/{dispute_id}/accept`
                .replace(`{${"dispute_id"}}`, encodeURIComponent(String(disputeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["PAYMENTS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads text to use as evidence for a dispute challenge.
         * @summary CreateDisputeEvidenceText
         * @param {string} disputeId The ID of the dispute you want to upload evidence for.
         * @param {CreateDisputeEvidenceTextRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDisputeEvidenceText: async (disputeId: string, body: CreateDisputeEvidenceTextRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'disputeId' is not null or undefined
            if (disputeId === null || disputeId === undefined) {
                throw new RequiredError('disputeId','Required parameter disputeId was null or undefined when calling createDisputeEvidenceText.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createDisputeEvidenceText.');
            }
            const localVarPath = `/v2/disputes/{dispute_id}/evidence_text`
                .replace(`{${"dispute_id"}}`, encodeURIComponent(String(disputeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["PAYMENTS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of evidence associated with a dispute.
         * @summary ListDisputeEvidence
         * @param {string} disputeId The ID of the dispute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputeEvidence: async (disputeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'disputeId' is not null or undefined
            if (disputeId === null || disputeId === undefined) {
                throw new RequiredError('disputeId','Required parameter disputeId was null or undefined when calling listDisputeEvidence.');
            }
            const localVarPath = `/v2/disputes/{dispute_id}/evidence`
                .replace(`{${"dispute_id"}}`, encodeURIComponent(String(disputeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["PAYMENTS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of disputes associated with a particular account.
         * @summary ListDisputes
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query. For more information, see [Paginating](https://developer.squareup.com/docs/basics/api101/pagination).
         * @param {string} [states] The dispute states to filter the result. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or &#x60;LOST&#x60;).
         * @param {string} [locationId] The ID of the location for which to return  a list of disputes. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or  &#x60;LOST&#x60;) associated with all locations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputes: async (cursor?: string, states?: string, locationId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/disputes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["PAYMENTS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (states !== undefined) {
                localVarQueryParameter['states'] = states;
            }

            if (locationId !== undefined) {
                localVarQueryParameter['location_id'] = locationId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes specified evidence from a dispute.  Square does not send the bank any evidence that is removed. Also, you cannot remove evidence after submitting it to the bank using [SubmitEvidence](/reference/square/disputes-api/submit-evidence).
         * @summary RemoveDisputeEvidence
         * @param {string} disputeId The ID of the dispute you want to remove evidence from.
         * @param {string} evidenceId The ID of the evidence you want to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDisputeEvidence: async (disputeId: string, evidenceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'disputeId' is not null or undefined
            if (disputeId === null || disputeId === undefined) {
                throw new RequiredError('disputeId','Required parameter disputeId was null or undefined when calling removeDisputeEvidence.');
            }
            // verify required parameter 'evidenceId' is not null or undefined
            if (evidenceId === null || evidenceId === undefined) {
                throw new RequiredError('evidenceId','Required parameter evidenceId was null or undefined when calling removeDisputeEvidence.');
            }
            const localVarPath = `/v2/disputes/{dispute_id}/evidence/{evidence_id}`
                .replace(`{${"dispute_id"}}`, encodeURIComponent(String(disputeId)))
                .replace(`{${"evidence_id"}}`, encodeURIComponent(String(evidenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["PAYMENTS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of a specific dispute.
         * @summary RetrieveDispute
         * @param {string} disputeId The ID of the dispute you want more details about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDispute: async (disputeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'disputeId' is not null or undefined
            if (disputeId === null || disputeId === undefined) {
                throw new RequiredError('disputeId','Required parameter disputeId was null or undefined when calling retrieveDispute.');
            }
            const localVarPath = `/v2/disputes/{dispute_id}`
                .replace(`{${"dispute_id"}}`, encodeURIComponent(String(disputeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["PAYMENTS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specific evidence metadata associated with a specific dispute.  You must maintain a copy of the evidence you upload if you want to reference it later. You cannot download the evidence after you upload it.
         * @summary RetrieveDisputeEvidence
         * @param {string} disputeId The ID of the dispute that you want to retrieve evidence from.
         * @param {string} evidenceId The ID of the evidence to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDisputeEvidence: async (disputeId: string, evidenceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'disputeId' is not null or undefined
            if (disputeId === null || disputeId === undefined) {
                throw new RequiredError('disputeId','Required parameter disputeId was null or undefined when calling retrieveDisputeEvidence.');
            }
            // verify required parameter 'evidenceId' is not null or undefined
            if (evidenceId === null || evidenceId === undefined) {
                throw new RequiredError('evidenceId','Required parameter evidenceId was null or undefined when calling retrieveDisputeEvidence.');
            }
            const localVarPath = `/v2/disputes/{dispute_id}/evidence/{evidence_id}`
                .replace(`{${"dispute_id"}}`, encodeURIComponent(String(disputeId)))
                .replace(`{${"evidence_id"}}`, encodeURIComponent(String(evidenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["PAYMENTS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits evidence to the cardholder\'s bank.  Before submitting evidence, Square compiles all available evidence. This includes evidence uploaded using the [CreateDisputeEvidenceFile](/reference/square/disputes-api/create-dispute-evidence-file) and [CreateDisputeEvidenceText](/reference/square/disputes-api/create-dispute-evidence-text) endpoints, and evidence automatically provided by Square, when available.
         * @summary SubmitEvidence
         * @param {string} disputeId The ID of the dispute you want to submit evidence for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitEvidence: async (disputeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'disputeId' is not null or undefined
            if (disputeId === null || disputeId === undefined) {
                throw new RequiredError('disputeId','Required parameter disputeId was null or undefined when calling submitEvidence.');
            }
            const localVarPath = `/v2/disputes/{dispute_id}/submit-evidence`
                .replace(`{${"dispute_id"}}`, encodeURIComponent(String(disputeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["PAYMENTS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisputesApi - functional programming interface
 * @export
 */
export const DisputesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Accepts loss on a dispute. Square returns the disputed amount to the cardholder and updates the dispute state to ACCEPTED.  Square debits the disputed amount from the seller’s Square account. If the Square account balance does not have sufficient funds, Square debits the associated bank account.
         * @summary AcceptDispute
         * @param {string} disputeId ID of the dispute you want to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptDispute(disputeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AcceptDisputeResponse>> {
            const localVarAxiosArgs = await DisputesApiAxiosParamCreator(configuration).acceptDispute(disputeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Uploads text to use as evidence for a dispute challenge.
         * @summary CreateDisputeEvidenceText
         * @param {string} disputeId The ID of the dispute you want to upload evidence for.
         * @param {CreateDisputeEvidenceTextRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDisputeEvidenceText(disputeId: string, body: CreateDisputeEvidenceTextRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDisputeEvidenceTextResponse>> {
            const localVarAxiosArgs = await DisputesApiAxiosParamCreator(configuration).createDisputeEvidenceText(disputeId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of evidence associated with a dispute.
         * @summary ListDisputeEvidence
         * @param {string} disputeId The ID of the dispute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDisputeEvidence(disputeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDisputeEvidenceResponse>> {
            const localVarAxiosArgs = await DisputesApiAxiosParamCreator(configuration).listDisputeEvidence(disputeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of disputes associated with a particular account.
         * @summary ListDisputes
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query. For more information, see [Paginating](https://developer.squareup.com/docs/basics/api101/pagination).
         * @param {string} [states] The dispute states to filter the result. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or &#x60;LOST&#x60;).
         * @param {string} [locationId] The ID of the location for which to return  a list of disputes. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or  &#x60;LOST&#x60;) associated with all locations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDisputes(cursor?: string, states?: string, locationId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDisputesResponse>> {
            const localVarAxiosArgs = await DisputesApiAxiosParamCreator(configuration).listDisputes(cursor, states, locationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes specified evidence from a dispute.  Square does not send the bank any evidence that is removed. Also, you cannot remove evidence after submitting it to the bank using [SubmitEvidence](/reference/square/disputes-api/submit-evidence).
         * @summary RemoveDisputeEvidence
         * @param {string} disputeId The ID of the dispute you want to remove evidence from.
         * @param {string} evidenceId The ID of the evidence you want to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDisputeEvidence(disputeId: string, evidenceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveDisputeEvidenceResponse>> {
            const localVarAxiosArgs = await DisputesApiAxiosParamCreator(configuration).removeDisputeEvidence(disputeId, evidenceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns details of a specific dispute.
         * @summary RetrieveDispute
         * @param {string} disputeId The ID of the dispute you want more details about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveDispute(disputeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveDisputeResponse>> {
            const localVarAxiosArgs = await DisputesApiAxiosParamCreator(configuration).retrieveDispute(disputeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the specific evidence metadata associated with a specific dispute.  You must maintain a copy of the evidence you upload if you want to reference it later. You cannot download the evidence after you upload it.
         * @summary RetrieveDisputeEvidence
         * @param {string} disputeId The ID of the dispute that you want to retrieve evidence from.
         * @param {string} evidenceId The ID of the evidence to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveDisputeEvidence(disputeId: string, evidenceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveDisputeEvidenceResponse>> {
            const localVarAxiosArgs = await DisputesApiAxiosParamCreator(configuration).retrieveDisputeEvidence(disputeId, evidenceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Submits evidence to the cardholder\'s bank.  Before submitting evidence, Square compiles all available evidence. This includes evidence uploaded using the [CreateDisputeEvidenceFile](/reference/square/disputes-api/create-dispute-evidence-file) and [CreateDisputeEvidenceText](/reference/square/disputes-api/create-dispute-evidence-text) endpoints, and evidence automatically provided by Square, when available.
         * @summary SubmitEvidence
         * @param {string} disputeId The ID of the dispute you want to submit evidence for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitEvidence(disputeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitEvidenceResponse>> {
            const localVarAxiosArgs = await DisputesApiAxiosParamCreator(configuration).submitEvidence(disputeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DisputesApi - factory interface
 * @export
 */
export const DisputesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Accepts loss on a dispute. Square returns the disputed amount to the cardholder and updates the dispute state to ACCEPTED.  Square debits the disputed amount from the seller’s Square account. If the Square account balance does not have sufficient funds, Square debits the associated bank account.
         * @summary AcceptDispute
         * @param {string} disputeId ID of the dispute you want to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDispute(disputeId: string, options?: any): AxiosPromise<AcceptDisputeResponse> {
            return DisputesApiFp(configuration).acceptDispute(disputeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads text to use as evidence for a dispute challenge.
         * @summary CreateDisputeEvidenceText
         * @param {string} disputeId The ID of the dispute you want to upload evidence for.
         * @param {CreateDisputeEvidenceTextRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDisputeEvidenceText(disputeId: string, body: CreateDisputeEvidenceTextRequest, options?: any): AxiosPromise<CreateDisputeEvidenceTextResponse> {
            return DisputesApiFp(configuration).createDisputeEvidenceText(disputeId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of evidence associated with a dispute.
         * @summary ListDisputeEvidence
         * @param {string} disputeId The ID of the dispute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputeEvidence(disputeId: string, options?: any): AxiosPromise<ListDisputeEvidenceResponse> {
            return DisputesApiFp(configuration).listDisputeEvidence(disputeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of disputes associated with a particular account.
         * @summary ListDisputes
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query. For more information, see [Paginating](https://developer.squareup.com/docs/basics/api101/pagination).
         * @param {string} [states] The dispute states to filter the result. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or &#x60;LOST&#x60;).
         * @param {string} [locationId] The ID of the location for which to return  a list of disputes. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or  &#x60;LOST&#x60;) associated with all locations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputes(cursor?: string, states?: string, locationId?: string, options?: any): AxiosPromise<ListDisputesResponse> {
            return DisputesApiFp(configuration).listDisputes(cursor, states, locationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes specified evidence from a dispute.  Square does not send the bank any evidence that is removed. Also, you cannot remove evidence after submitting it to the bank using [SubmitEvidence](/reference/square/disputes-api/submit-evidence).
         * @summary RemoveDisputeEvidence
         * @param {string} disputeId The ID of the dispute you want to remove evidence from.
         * @param {string} evidenceId The ID of the evidence you want to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDisputeEvidence(disputeId: string, evidenceId: string, options?: any): AxiosPromise<RemoveDisputeEvidenceResponse> {
            return DisputesApiFp(configuration).removeDisputeEvidence(disputeId, evidenceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns details of a specific dispute.
         * @summary RetrieveDispute
         * @param {string} disputeId The ID of the dispute you want more details about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDispute(disputeId: string, options?: any): AxiosPromise<RetrieveDisputeResponse> {
            return DisputesApiFp(configuration).retrieveDispute(disputeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specific evidence metadata associated with a specific dispute.  You must maintain a copy of the evidence you upload if you want to reference it later. You cannot download the evidence after you upload it.
         * @summary RetrieveDisputeEvidence
         * @param {string} disputeId The ID of the dispute that you want to retrieve evidence from.
         * @param {string} evidenceId The ID of the evidence to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDisputeEvidence(disputeId: string, evidenceId: string, options?: any): AxiosPromise<RetrieveDisputeEvidenceResponse> {
            return DisputesApiFp(configuration).retrieveDisputeEvidence(disputeId, evidenceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits evidence to the cardholder\'s bank.  Before submitting evidence, Square compiles all available evidence. This includes evidence uploaded using the [CreateDisputeEvidenceFile](/reference/square/disputes-api/create-dispute-evidence-file) and [CreateDisputeEvidenceText](/reference/square/disputes-api/create-dispute-evidence-text) endpoints, and evidence automatically provided by Square, when available.
         * @summary SubmitEvidence
         * @param {string} disputeId The ID of the dispute you want to submit evidence for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitEvidence(disputeId: string, options?: any): AxiosPromise<SubmitEvidenceResponse> {
            return DisputesApiFp(configuration).submitEvidence(disputeId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DisputesApi - object-oriented interface
 * @export
 * @class DisputesApi
 * @extends {BaseAPI}
 */
export class DisputesApi extends BaseAPI {
    /**
     * Accepts loss on a dispute. Square returns the disputed amount to the cardholder and updates the dispute state to ACCEPTED.  Square debits the disputed amount from the seller’s Square account. If the Square account balance does not have sufficient funds, Square debits the associated bank account.
     * @summary AcceptDispute
     * @param {string} disputeId ID of the dispute you want to accept.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    public acceptDispute(disputeId: string, options?: any) {
        return DisputesApiFp(this.configuration).acceptDispute(disputeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads text to use as evidence for a dispute challenge.
     * @summary CreateDisputeEvidenceText
     * @param {string} disputeId The ID of the dispute you want to upload evidence for.
     * @param {CreateDisputeEvidenceTextRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    public createDisputeEvidenceText(disputeId: string, body: CreateDisputeEvidenceTextRequest, options?: any) {
        return DisputesApiFp(this.configuration).createDisputeEvidenceText(disputeId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of evidence associated with a dispute.
     * @summary ListDisputeEvidence
     * @param {string} disputeId The ID of the dispute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    public listDisputeEvidence(disputeId: string, options?: any) {
        return DisputesApiFp(this.configuration).listDisputeEvidence(disputeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of disputes associated with a particular account.
     * @summary ListDisputes
     * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query. For more information, see [Paginating](https://developer.squareup.com/docs/basics/api101/pagination).
     * @param {string} [states] The dispute states to filter the result. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or &#x60;LOST&#x60;).
     * @param {string} [locationId] The ID of the location for which to return  a list of disputes. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or  &#x60;LOST&#x60;) associated with all locations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    public listDisputes(cursor?: string, states?: string, locationId?: string, options?: any) {
        return DisputesApiFp(this.configuration).listDisputes(cursor, states, locationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes specified evidence from a dispute.  Square does not send the bank any evidence that is removed. Also, you cannot remove evidence after submitting it to the bank using [SubmitEvidence](/reference/square/disputes-api/submit-evidence).
     * @summary RemoveDisputeEvidence
     * @param {string} disputeId The ID of the dispute you want to remove evidence from.
     * @param {string} evidenceId The ID of the evidence you want to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    public removeDisputeEvidence(disputeId: string, evidenceId: string, options?: any) {
        return DisputesApiFp(this.configuration).removeDisputeEvidence(disputeId, evidenceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details of a specific dispute.
     * @summary RetrieveDispute
     * @param {string} disputeId The ID of the dispute you want more details about.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    public retrieveDispute(disputeId: string, options?: any) {
        return DisputesApiFp(this.configuration).retrieveDispute(disputeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specific evidence metadata associated with a specific dispute.  You must maintain a copy of the evidence you upload if you want to reference it later. You cannot download the evidence after you upload it.
     * @summary RetrieveDisputeEvidence
     * @param {string} disputeId The ID of the dispute that you want to retrieve evidence from.
     * @param {string} evidenceId The ID of the evidence to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    public retrieveDisputeEvidence(disputeId: string, evidenceId: string, options?: any) {
        return DisputesApiFp(this.configuration).retrieveDisputeEvidence(disputeId, evidenceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits evidence to the cardholder\'s bank.  Before submitting evidence, Square compiles all available evidence. This includes evidence uploaded using the [CreateDisputeEvidenceFile](/reference/square/disputes-api/create-dispute-evidence-file) and [CreateDisputeEvidenceText](/reference/square/disputes-api/create-dispute-evidence-text) endpoints, and evidence automatically provided by Square, when available.
     * @summary SubmitEvidence
     * @param {string} disputeId The ID of the dispute you want to submit evidence for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    public submitEvidence(disputeId: string, options?: any) {
        return DisputesApiFp(this.configuration).submitEvidence(disputeId, options).then((request) => request(this.axios, this.basePath));
    }
}
